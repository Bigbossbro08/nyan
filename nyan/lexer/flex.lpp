%{
// Copyright 2016-2017 the nyan authors, LGPLv3+. See copying.md for legal info.

/**
 * @file
 * nyan language lexer
 */

#include <string>

#include "impl.h"

using namespace std::string_literals;

// Downcast `this` into our custom implementation
#define impl static_cast<nyan::lexer::Impl *>(this)

// before matching a rule, advance the line position by length of current token
#define YY_USER_ACTION impl->linepos += this->yyleng;

%}


%option c++
%option warn nodefault
%option yylineno
%option nounistd
%option never-interactive


digit          [0-9]
id             [A-Za-z_][A-Za-z0-9_]*
operator       [-+*/|%&]=?|=
int            (-|0[xX])?{digit}+
float          -?({digit}+\.{digit}*|{digit}*\.{digit}+)

%%

^[ ]*#[^\n]*\n    { /* comments in empty lines */ impl->reset_linepos(); }
"#"[^\n]*\n       { /* trailing comments */ impl->endline(); }

"\t"              { throw impl->error("tab character"); }

^[ ]*\n           { /* ignore blank lines. */ impl->reset_linepos(); }

^[ ]*[^ \n]+      { /* indent */
    int last = this->yyleng - 1;
    impl->handle_indent(this->yytext);

    // walk from right to left until the indent begin is found
    while ((last >= 0) && (this->yytext[last] != ' ')) {
        unput(this->yytext[last]);
        last--;
        --impl->linepos;
    }
}

\"(\\.|[^\\"])*\"       { impl->token(nyan::token_type::STRING); yyterminate(); }
\'(\\.|[^\\'])*\'       { impl->token(nyan::token_type::STRING); yyterminate(); }

"\n"                    { /* don't assign the `\n` for the next line */
                          impl->endline(); yyterminate(); }

"("                     { impl->token(nyan::token_type::LPAREN); yyterminate(); }
")"                     { impl->token(nyan::token_type::RPAREN); yyterminate(); }
"<"                     { impl->token(nyan::token_type::LANGLE); yyterminate(); }
">"                     { impl->token(nyan::token_type::RANGLE); yyterminate(); }
"["                     { impl->token(nyan::token_type::LBRACKET); yyterminate(); }
"]"                     { impl->token(nyan::token_type::RBRACKET); yyterminate(); }
"{"                     { impl->token(nyan::token_type::LBRACE); yyterminate(); }
"}"                     { impl->token(nyan::token_type::RBRACE); yyterminate(); }
"@"                     { impl->token(nyan::token_type::AT); yyterminate(); }

"pass"                  { impl->token(nyan::token_type::PASS); yyterminate(); }
"..."                   { impl->token(nyan::token_type::ELLIPSIS); yyterminate(); }
"import"                { impl->token(nyan::token_type::IMPORT); yyterminate(); }
"from"                  { impl->token(nyan::token_type::FROM); yyterminate(); }
"as"                    { impl->token(nyan::token_type::AS); yyterminate(); }
{operator}              { impl->token(nyan::token_type::OPERATOR); yyterminate(); }
{int}                   { impl->token(nyan::token_type::INT); yyterminate(); }
{float}                 { impl->token(nyan::token_type::FLOAT); yyterminate(); }
{id}                    { impl->token(nyan::token_type::ID); yyterminate(); }
":"                     { impl->token(nyan::token_type::COLON); yyterminate(); }
","                     { impl->token(nyan::token_type::COMMA); yyterminate(); }
"."                     { impl->token(nyan::token_type::DOT); yyterminate(); }

[ \r]                   { /* ignore space */ }
"\f"                    { yylineno -= 1; }

<<EOF>>                 { impl->token(nyan::token_type::ENDFILE); yyterminate(); }

.                       { throw impl->error("invalid char: "s + yytext); }

%%


// No file wrapper needed for now.
// And of course the noyywrap option is broken and generates
// this snippet in both the header and cpp file.
int yyFlexLexer::yywrap() {
	return 1;
}
